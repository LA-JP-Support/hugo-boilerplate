---
title: OAuth
date: 2025-12-19
translationKey: OAuth
description: "パスワードを共有せずに、アプリがあなたのGoogleやFacebookなどのアカウント情報に安全にアクセスできる仕組み。"
keywords:
- OAuth
- 認可フレームワーク
- APIセキュリティ
- アクセストークン
- 認証プロトコル
category: Application & Use-Cases
type: glossary
draft: false
e-title: OAuth
url: /ja/glossary/OAuth/
term: オーオース
---

## OAuthとは何か?
OAuth(Open Authorization)は、HTTPサービス上のユーザーアカウントへの限定的なアクセスを、ユーザー認証情報を公開することなくアプリケーションが取得できるようにする、オープン標準の認可フレームワークです。2006年にTwitterなどの企業によって開発されたOAuthは、インターネット全体における安全なAPI認可のデファクトスタンダードへと進化しました。このフレームワークにより、サードパーティアプリケーションは、Google、Facebook、GitHub、その他無数のプラットフォームなどのサービスプロバイダーからユーザーデータにアクセスする際、ユーザーがパスワードを直接これらのアプリケーションと共有する必要がなくなります。

OAuthの根本的な原則は、認証ではなく認可の委譲です。ユーザーアカウントへの完全なアクセスを付与する従来のユーザー名とパスワードの組み合わせとは異なり、OAuthは、ユーザーが特定の限定的な権限を、定義された期間、アプリケーションに付与するメカニズムを提供します。このアプローチは、アプリケーションがユーザー認証情報を保存する必要性を排除し、サードパーティアプリケーションがアクセスできるデータとアクションに対する詳細な制御を提供することで、セキュリティリスクを大幅に軽減します。このフレームワークは、トークン(特定の認可付与を表す一時的で取り消し可能な認証情報)の概念に基づいて動作します。

OAuthは誕生以来、大きな進化を遂げており、2010年にOAuth 1.0がリリースされ、その後2012年により広く採用されたOAuth 2.0が続きました。OAuth 2.0は、堅牢なセキュリティ機能を維持しながら元の仕様を簡素化し、開発者にとってよりアクセスしやすく、現代のWebおよびモバイルアプリケーションにより適したものとなりました。このフレームワークは、サーバーサイドWebアプリケーションからモバイルアプリ、シングルページアプリケーションまで、さまざまなタイプのアプリケーション向けに設計された複数の認可フローをサポートしています。この柔軟性と、セキュリティ上の利点、業界全体での採用により、OAuthは現代のAPIエコシステムとデジタルアイデンティティ管理の不可欠なコンポーネントとなっています。

## OAuthの主要コンポーネント

**認可サーバー** - ユーザーを認証し、認可が成功した後にアクセストークンを発行するサーバー。このコンポーネントは、ユーザー認証情報を検証し、ユーザーに認可プロンプトを提示し、発行、更新、取り消しを含むトークンのライフサイクルを管理します。

**リソースサーバー** - 保護されたユーザーリソースをホストし、アクセストークンを受け入れて検証するサーバー。トークンのスコープと有効性に基づいてアクセス制御ポリシーを実施し、適切に認可されたリクエストのみが保護されたデータにアクセスしたり、特定のアクションを実行できるようにします。

**クライアントアプリケーション** - ユーザーに代わってユーザーリソースへのアクセスを要求するサードパーティアプリケーション。クライアントは、機密(認証情報を安全に保存できる)またはパブリック(認証情報の機密性を維持できない)のいずれかであり、これにより使用する適切なOAuthフローが決定されます。

**リソースオーナー** - 保護されたリソースへのアクセスを許可できるエンティティ、通常はエンドユーザー。リソースオーナーは、アクセスリクエストを承認または拒否する権限を持ち、以前に付与した権限をいつでも取り消すことができます。

**アクセストークン** - クライアントアプリケーションに付与された認可を表す認証情報。これらのトークンには、定義されたスコープ、有効期限があり、取り消すことができ、ユーザー認証情報を公開することなく、リソースアクセスに対する詳細な制御を提供します。

**リフレッシュトークン** - 現在のトークンが期限切れになったときに新しいアクセストークンを取得するために使用される長期間有効な認証情報。リフレッシュトークンにより、アプリケーションは繰り返しユーザー認証を要求することなく、認可されたアクセスを維持でき、シームレスなユーザーエクスペリエンスを実現します。

**認可グラント** - リソースオーナーの認可を表す認証情報で、クライアントがアクセストークンを取得するために使用します。さまざまなグラントタイプが、認可コード、インプリシット、クライアント認証情報、リソースオーナーパスワード認証情報グラントなど、さまざまなアプリケーションアーキテクチャとセキュリティ要件をサポートします。

## OAuthの仕組み

OAuth認可プロセスは、ユーザーがデータを制御しながら、アクセス権の安全な委譲を保証する明確に定義されたシーケンスに従います。

1. **クライアント登録** - アプリケーションは認可サーバーに登録し、クライアントIDとオプションでクライアントシークレットを受け取ります。これにより、アプリケーションのアイデンティティが確立され、OAuthエコシステム内での機能が決定されます。

2. **認可リクエスト** - アプリケーションがユーザーリソースへのアクセスを必要とする場合、クライアントID、要求されたスコープ、リダイレクトURI、レスポンスタイプを含むパラメータとともに、ユーザーを認可サーバーにリダイレクトします。

3. **ユーザー認証** - 認可サーバーは、ユーザーの好みの方法(パスワード、多要素認証、生体認証)を通じてユーザーを認証し、要求された権限を詳述する認可プロンプトを提示します。

4. **認可グラント** - ユーザーの同意を得ると、認可サーバーは認可コードを生成し、コードをパラメータとして含めて、クライアントアプリケーションの指定されたリダイレクトURIにユーザーをリダイレクトします。

5. **トークン交換** - クライアントアプリケーションは、認可コード、クライアント認証情報、リダイレクトURIを含めて、認可サーバーのトークンエンドポイントにサーバー間リクエストを行うことで、認可コードをアクセストークンと交換します。

6. **アクセストークン発行** - 認可サーバーはリクエストを検証し、定義されたスコープと有効期限を持つアクセストークン(およびオプションでリフレッシュトークン)を発行します。

7. **リソースアクセス** - クライアントアプリケーションは、通常はBearerトークンスキームを使用してAuthorizationヘッダーに、アクセストークンを含めてリソースサーバーへのAPIリクエストを行います。

8. **トークン検証** - リソースサーバーはアクセストークンを検証し、そのスコープと有効期限を確認し、トークンの認可に基づいて、要求されたリソースへのアクセスを許可または拒否します。

**ワークフローの例**: ユーザーのGoogleフォトへのアクセスを要求する写真印刷サービスは、ユーザーをGoogleの認可サーバーにリダイレクトし、そこでユーザーがログインして写真へのアクセス許可を付与します。Googleは認可コードを返し、印刷サービスはそれをアクセストークンと交換し、Googleの認証情報を一切扱うことなく、ユーザーの写真を取得できるようになります。

## 主な利点

**セキュリティの強化** - OAuthにより、サードパーティアプリケーションがユーザーパスワードを処理する必要がなくなり、認証情報の盗難や不正アクセスのリスクが大幅に軽減されます。ユーザーは、安全なデータ共有を可能にしながら、認証情報の制御を維持します。

**詳細な権限制御** - スコープメカニズムにより、ユーザーは完全なアカウントアクセスではなく、特定の限定的な権限を付与できます。ユーザーは、データを変更したり機密リソースにアクセスする権限を付与することなく、プロフィール情報を読み取る権限をアプリケーションに付与できます。

**取り消し可能なアクセス** - ユーザーは、認可サーバーの管理インターフェースを通じて、いつでもアプリケーションのアクセスを取り消すことができ、関連するすべてのトークンを即座に無効化します。これにより、データ共有関係に対する継続的な制御が提供され、セキュリティ上の懸念に迅速に対応できます。

**ユーザーエクスペリエンスの向上** - OAuthにより、ユーザーが信頼できるプロバイダーからの既存のアカウントを使用して複数のアプリケーションにアクセスできる、シングルサインオンエクスペリエンスが可能になります。これにより、パスワード疲労が軽減され、新しいアプリケーションのオンボーディングプロセスが合理化されます。

**標準化された実装** - オープン標準として、OAuthはさまざまなプラットフォームとサービス間で一貫した実装パターンを提供します。この標準化により、開発の複雑さが軽減され、異なるシステムとベンダー間の相互運用性が保証されます。

**トークンベースのアーキテクチャ** - アクセストークンは、特定の有効期間、スコープ、機能を持つように設計でき、詳細なアクセス制御を可能にします。短期間有効なトークンはトークン侵害の影響を軽減し、リフレッシュトークンはシームレスなアクセス更新を可能にします。

**スケーラブルな認可** - OAuthは、複数のグラントタイプとフローを通じて、さまざまなアプリケーションタイプと展開シナリオをサポートします。この柔軟性により、サーバーサイドWebアプリケーションからモバイルアプリ、IoTデバイスまで、あらゆるものに対応できます。

**監査とモニタリング** - トークンベースのアプローチにより、APIアクセスパターンの包括的なログ記録とモニタリングが可能になります。組織は、どのアプリケーションがどのデータにアクセスしているかを追跡し、セキュリティ問題を示す可能性のある異常なアクセスパターンを特定できます。

**責任の軽減** - ユーザー認証情報を直接処理しないことで、アプリケーションはセキュリティ責任とコンプライアンス負担を軽減します。これは、機密データを扱うアプリケーションや規制された業界で運営されるアプリケーションにとって特に重要です。

**フェデレーションサポート** - OAuthはアイデンティティフェデレーションプロトコルとうまく統合され、複雑な複数組織の認可シナリオを可能にします。これは、ユーザーが組織の境界を越えてリソースにアクセスする必要があるエンタープライズユースケースをサポートします。

## 一般的なユースケース

**ソーシャルメディア統合** - アプリケーションは、Facebook、Twitter、LinkedInなどのプラットフォームと統合し、ユーザーがコンテンツを共有したり、ソーシャルコネクションをインポートしたり、ソーシャルメディアアカウントを使用して認証できるようにします。

**クラウドストレージアクセス** - ファイル管理およびバックアップアプリケーションは、Google Drive、Dropbox、OneDrive、その他のクラウドストレージサービスに保存されたユーザーデータにアクセスして、ファイルを同期、バックアップ、または処理します。

**APIゲートウェイ認可** - エンタープライズAPIゲートウェイは、OAuthを使用して内部および外部APIへのアクセスを制御し、認可されたアプリケーションとユーザーのみが特定のリソースと操作にアクセスできるようにします。

**モバイルアプリケーション認証** - モバイルアプリは、OAuthを使用して既存のアカウント(Google、Apple、Microsoft)を通じてユーザーを認証し、カスタム認証システムを実装したり、ユーザー認証情報をローカルに保存したりする必要がありません。

**エンタープライズシングルサインオン** - 組織は、OAuthベースのSSOソリューションを実装して、従業員が企業の認証情報を使用して複数の内部および外部アプリケーションにアクセスできるようにします。

**IoTデバイス認可** - モノのインターネットデバイスは、OAuthを使用して、デバイスファームウェアに長期間有効な認証情報を埋め込むことなく、クラウドサービスとAPIに安全にアクセスします。

**マイクロサービスセキュリティ** - 分散アプリケーションは、OAuthトークンを使用してマイクロサービス間の通信を保護し、各サービスが受信リクエストのアイデンティティと権限を検証できるようにします。

**サードパーティ統合** - SaaSアプリケーションは、OAuthを使用して他のビジネスツールと統合し、CRMシステム、マーケティングプラットフォーム、会計ソフトウェア、生産性ツール間のデータ同期を可能にします。

**開発者プラットフォームアクセス** - コードリポジトリ、CI/CDプラットフォーム、開発ツールは、OAuthを使用して、詳細な権限制御を維持しながら、開発者リソースへの安全なアクセスを提供します。

**金融サービス統合** - フィンテックアプリケーションは、OAuthを使用してオープンバンキングイニシアチブを通じて銀行APIと金融データに安全にアクセスし、アカウント集約と財務管理サービスを可能にします。

## OAuthフローの比較

| フロータイプ | ユースケース | クライアントタイプ | セキュリティレベル | 複雑さ |
|-----------|----------|-------------|----------------|------------|
| 認可コード | サーバーサイドWebアプリ | 機密 | 高 | 中 |
| 認可コード + PKCE | モバイル/SPAアプリ | パブリック | 高 | 高 |
| インプリシット | レガシーSPA | パブリック | 中 | 低 |
| クライアント認証情報 | サービス間 | 機密 | 高 | 低 |
| リソースオーナーパスワード | 信頼されたアプリケーション | 両方 | 低 | 低 |
| デバイス認可 | 入力が限られたデバイス | パブリック | 中 | 中 |

## 課題と考慮事項

**トークン管理の複雑さ** - アプリケーションは、さまざまな環境とユーザーセッション間で、トークンの保存、更新、取り消しを適切に処理する必要があります。トークン管理が不適切だと、セキュリティの脆弱性やユーザーエクスペリエンスの低下につながる可能性があります。

**スコープクリープと過剰な権限付与** - アプリケーションは、必要以上に広範な権限を要求する可能性があり、最小権限の原則に違反します。ユーザーは、認可決定の影響を完全に理解せずに、過剰な権限を付与することがよくあります。

**クロスサイトリクエストフォージェリ(CSRF)** - 適切なstateパラメータと検証メカニズムが実装されていない場合、OAuth実装はCSRF攻撃に対して脆弱です。攻撃者は、ユーザーを騙して悪意のあるアプリケーションを認可させる可能性があります。

**リダイレクトURI検証** - リダイレクトURIの不適切な検証により、認可コード傍受攻撃が可能になる可能性があります。アプリケーションは、パターンマッチングではなく完全一致を使用して、厳格なURI検証を実装する必要があります。

**トークン漏洩リスク** - URL、ログ、またはリファラーヘッダーを通じて送信されるアクセストークンは、権限のない第三者に公開される可能性があります。これは、インプリシットフローの実装と不適切に構成されたログシステムにとって特に懸念されます。

**フィッシングとソーシャルエンジニアリング** - ユーザーは、正規のサービスになりすました悪意のあるアプリケーションを認可するように騙される可能性があります。OAuth同意画面は、危険な権限を要求しながら信頼できるように見えるように操作される可能性があります。

**実装の不整合** - 異なるOAuthプロバイダーは仕様を異なる方法で実装する可能性があり、互換性の問題と統合の課題につながります。開発者は、プロバイダー固有の動作と要件を考慮する必要があります。

**セッション管理の複雑さ** - OAuthトークンのライフサイクルとアプリケーションセッション管理を調整することは、特に分散システムや複数の同時セッションをサポートする場合、複雑になる可能性があります。

**リフレッシュトークンのセキュリティ** - 長期間有効なリフレッシュトークンは、侵害された場合、新しいアクセストークンを生成するために使用できるため、セキュリティリスクをもたらします。適切なリフレッシュトークンのローテーションと保存メカニズムが不可欠です。

**コンプライアンスとプライバシーの懸念** - OAuth実装は、GDPRやCCPAなどのデータ保護規制に準拠する必要があり、データアクセスパターン、ユーザーの同意、データ保持ポリシーを慎重に検討する必要があります。

## 実装のベストプラクティス

**PKCEを使用した認可コードフローの使用** - アプリケーションタイプに適した最も安全なOAuthフローを実装し、パブリッククライアントには認可コード傍受攻撃を防ぐためにPKCE(Proof Key for Code Exchange)を使用します。

**適切なstate検証の実装** - CSRF攻撃を防ぎ、認可レスポンスがアプリケーションからの正当なリクエストに対応していることを確認するために、常にstateパラメータを使用して検証します。

**トークンスコープの最小化** - アプリケーションの機能に必要な最小限の権限のみを要求し、最小権限の原則に従ってセキュリティリスクを軽減し、ユーザーの信頼を向上させます。

**トークンの安全な保存** - Webアプリケーション用の安全なHTTPのみのCookieやモバイルアプリケーション用のキーチェーンサービスなど、プラットフォームに適したメカニズムを使用してトークンを安全に保存します。

**トークン更新ロジックの実装** - 有効期限を適切に処理し、必要に応じてユーザーの再認証を含む、更新失敗に対する適切なエラー処理を実装する、堅牢なトークン更新メカニズムを構築します。

**リダイレクトURIの厳格な検証** - リダイレクトURI検証には完全文字列一致を使用し、リダイレクト攻撃を防ぐために、すべての可能なリダイレクトURIを認可サーバーに登録します。

**OAuthイベントの監視とログ記録** - トークンや認可コードなどの機密情報がログに記録されないようにしながら、OAuthフロー、トークン使用、セキュリティイベントの包括的なログ記録を実装します。

**エラーの適切な処理** - ネットワーク障害、無効なトークン、認可拒否を含むすべてのOAuthシナリオに対して適切なエラー処理を実装し、機密情報を公開することなく、ユーザーに明確なフィードバックを提供します。

**定期的なセキュリティ監査** - 侵入テストとコードレビューを含む、OAuth実装の定期的なセキュリティレビューを実施して、潜在的な脆弱性を特定して対処します。

**ライブラリの最新状態の維持** - よく保守されたOAuthライブラリを使用し、セキュリティパッチと改善の恩恵を受けるために最新の状態に保ち、OAuth仕様のカスタム実装を避けます。

## 高度なテクニック

**動的クライアント登録** - アプリケーションがプログラムで認可サーバーに自身を登録できるようにする自動クライアント登録機能を実装し、スケーラブルなマルチテナントアーキテクチャを可能にし、管理オーバーヘッドを削減します。

**トークンイントロスペクションと検証** - OAuthトークンイントロスペクションエンドポイントを利用して、トークンのステータス、スコープ、メタデータをリアルタイムで検証し、より高度なアクセス制御決定と改善されたセキュリティモニタリングを可能にします。

**JWTベースのアクセストークン** - アクセストークンにJSON Web Token(JWT)形式を実装して、ステートレスなトークン検証を可能にし、サーバーサイドのトークンルックアップを必要とせずに、強化された認可決定のためのカスタムクレームを含めます。

**相互TLSクライアント認証** - クライアント認証に相互TLS(mTLS)を実装してセキュリティを強化し、従来のクライアントシークレットよりも強力なクライアントアイデンティティ検証を提供します。これは、高セキュリティ環境で特に重要です。

**リッチ認可リクエスト** - OAuth 2.0リッチ認可リクエスト(RAR)を実装して、単純なスコープを超えた詳細な認可の詳細を提供し、より正確な権限リクエストと改善されたユーザー同意エクスペリエンスを可能にします。

**プッシュ認可リクエスト** - OAuth 2.0プッシュ認可リクエスト(PAR)を使用して、ブラウザリダイレクトではなく安全なバックチャネルを通じて認可リクエストパラメータを送信することでセキュリティを強化し、機密リクエストデータの露出を減らします。

## 今後の方向性

**OAuth 2.1の標準化** - 今後のOAuth 2.1仕様は、さまざまな拡張機能からのベストプラクティスとセキュリティ改善を統合し、すべてのクライアントにPKCEを義務付け、インプリシットグラントなどの安全性の低いフローを非推奨にします。

**ゼロトラストアーキテクチャ統合** - OAuthは、継続的な認証と認可を伴うゼロトラストセキュリティモデルをサポートするように進化しており、リアルタイムのリスク評価に基づいて、より動的でコンテキストを認識したアクセス制御決定を可能にします。

**分散型アイデンティティ統合** - 分散型アイデンティティシステムと自己主権アイデンティティの概念との統合により、ユーザーはOAuthの認可機能の恩恵を受けながら、デジタルアイデンティティに対するより大きな制御を維持できるようになります。

**強化されたプライバシー制御** - 将来のOAuth開発は、機能を維持しながらデータ露出を最小限に抑える、選択的開示機能やプライバシー保護トークン設計を含む、プライバシー保護認可メカニズムに焦点を当てています。

**IoTとエッジコンピューティングの最適化** - OAuthプロトコルは、リソース制約のある環境とエッジコンピューティングシナリオに適応されており、IoTデバイスとエッジアプリケーション向けの軽量トークン形式と最適化されたフローを備えています。

**機械学習統合** - AIと機械学習技術がOAuthシステムに統合され、行動分析と脅威インテリジェンスに基づいた、改善された不正検出、リスクベースの認証、自動化されたセキュリティポリシー実施が実現されています。

## 参考文献

1. Hardt, D. (2012). The OAuth 2.0 Authorization Framework. RFC 6749. Internet Engineering Task Force.
2. Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., & Mortimore, C. (2014). OpenID Connect Core 1.0. OpenID Foundation.
3. Lodderstedt, T., Bradley, J., Labunets, A., & Fett, D. (2020). OAuth 2.0 Security Best Current Practice. Internet-Draft. Internet Engineering Task Force.
4. Parecki, A. (2020). OAuth 2.0 Simplified. Self-published technical guide on OAuth implementation.
5. Jones, M., Bradley, J., & Sakimura, N. (2015). JSON Web Token (JWT). RFC 7519. Internet Engineering Task Force.
6. Campbell, B., Bradley, J., Sakimura, N., & Lodderstedt, T. (2018). OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access Tokens. RFC 8705.
7. Lodderstedt, T., Campbell, B., Sakimura, N., Tonge, D., & Scurtescu, F. (2021). OAuth 2.0 Rich Authorization Requests. Internet-Draft. Internet Engineering Task Force.
8. Fett, D., Campbell, B., Bradley, J., Lodderstedt, T., Jones, M., & Tschofenig, H. (2021). OAuth 2.1 Authorization Framework. Internet-Draft. Internet Engineering Task Force.