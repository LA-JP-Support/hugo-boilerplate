---
title: スロットフィリング
translationKey: slot-filling-the-definitive-glossary-for-conversational
description: スロットフィリングは、会話型AIにおいてユーザーのクエリから特定のパラメータを抽出し、タスクを完了させる技術です。データ収集、自然な対話の実現、タスク完了の確実性を担保するために不可欠な機能です。
keywords:
- スロットフィリング
- 会話型AI
- チャットボット
- エンティティ
- インテント
category: AI Chatbot & Automation
type: glossary
date: '2025-12-19'
lastmod: '2025-12-19'
draft: false
e-title: Slot Filling
term: すろっとふぃりんぐ
url: "/ja/glossary/Slot-Filling/"
---
## スロットフィリングとは?
スロットフィリングは、会話型AIのタスク指向対話システムにおける中核的な技術です。ユーザーのクエリから必要なパラメータ(スロットと呼ばれる)を識別・抽出することに焦点を当てています。これらのスロットは、フライトの予約、食事の注文、予約のスケジュール設定など、特定のアクションを実行するために必要です。

例えば、「7月20日にニューヨークからロンドンへのフライトを予約して」というクエリでは、会話エージェントは以下を抽出する必要があります:
- **出発都市:** ニューヨーク
- **目的地都市:** ロンドン
- **日付:** 7月20日

スロットフィリングは、AIがこの情報を解析し、保存し、ユーザーに代わって応答またはアクションを実行するために効果的に使用できるようにするメカニズムです。情報が不足している場合、システムはユーザーに提供を促し、タスクに必要な完全なデータセットを確保します。

スロットフィリングは、AIシステムがユーザーのリクエストを完了するために必要なすべてのデータを収集し、ユーザーが複数の会話ターンにわたって任意の順序で自然に情報を提供できるようにし、初期クエリから最大限の情報を抽出することで不要なやり取りを削減し、アクションを実行する前に完全性と正確性を確保するために不可欠です。

## 主要概念:スロット、エンティティ、インテント

**インテント:** ユーザーの目標または目的(例:「ホテルを予約する」、「ピザを注文する」)。

**スロット:** インテントを実行するために必要な、または任意の情報の一部のプレースホルダー(例:「チェックイン日」、「ピザのサイズ」)。

**エンティティ:** スロットが期待するデータ型または情報のカテゴリー(例:都市、日付、数値、アイテムタイプ)。

**関係性:**  
インテントはアクションを定義し、スロットはそのアクションに必要なパラメータであり、エンティティは各スロットが期待するデータの種類を記述します。

## エンティティの種類

エンティティにより、チャットボットはユーザー入力から関連データを認識・抽出できます:

### 組み込み/システムエンティティ

会話プラットフォームによって事前定義され、一般的なデータ型を処理します:
- 日付と時刻
- メールアドレス
- 電話番号
- 都市と場所
- 色、数値、通貨

### カスタムエンティティ

ドメイン固有のニーズに合わせて開発者が定義します:

**クローズドリストエンティティ:** 許容される値の列挙セット(例:ピザのトッピング、製品SKU)。

**正規表現(RegEx):** 構造化データを抽出するためのパターン(例:「INC000123」のようなチケット番号)。

カスタムエンティティは、専門的な語彙やデータ型を処理するボットの能力を拡張します。シノニムとファジーマッチングを使用してエンティティ認識を広げます(例:「NYC」を「New York City」のシノニムとして)。

## スロットフィリングプロセス

**1. 必要なスロットを定義:**  
特定のインテントを達成するために必要なすべての情報をリストアップします。

**2. 各スロットにエンティティを関連付け:**  
各スロットが受け入れるべきデータ型またはパターンを指定します。

**3. ユーザー入力からスロット値を抽出:**  
NLU(自然言語理解)を使用して、各スロットの値を識別・抽出します。

**4. 不足しているスロットを促す:**  
必須スロットが未入力の場合、ボットは不足している情報を収集するための質問をします。

**5. マルチターン対話を処理:**  
ユーザーが複数のメッセージにわたって任意の順序でスロットを埋められるようにします。

**6. 収集したスロット値を確認:**  
アクションを実行する前に、収集した情報をユーザーに提示して確認することができます(オプション)。

**7. タスクを実行:**  
すべての必須スロットが入力され確認されたら、実行(例:予約、注文、サポート)を進めます。

**視覚的な例:**

```
ユーザー: 「ピザを注文したいです。」
ボット: 「何枚のスライスをご希望ですか?」
ユーザー: 「8枚」
ボット: 「どのタイプのピザをご希望ですか?」
ユーザー: 「ペパロニ」
ボット: 「8枚のペパロニピザですね。よろしいですか?」
ユーザー: 「はい」
ボット: 「注文が確定しました!」
```

## スロット設定パラメータ

スロットを定義する際、設定オプションには以下が含まれます:

**名前:** スロットの識別子(例:`departure_city`)。

**エンティティ:** 期待されるデータ型—組み込みまたはカスタム。

**必須:** このスロットはタスクに必須ですか?はいの場合、ボットは入力されるまで、または終了するまで促す必要があります。

**配列:** スロットは複数の値を受け入れるべきですか(例:「2つのピザを注文:1つはマルゲリータ、1つはペパロニ」)?

**明確化質問:** 不足しているスロット値を要求する際に使用するプロンプト。

**デフォルト値:** スロットがオプションで未入力の場合のフォールバック値。

**リセット/上書き:** ユーザーが新しい情報を提供した場合、スロットの値を上書きすべきですか?

**最大リトライ/ガベージカウント:** プロセスを放棄する前に必要な情報を促す最大回数。

**確認:** アクションを進める前にユーザーとスロット値を確認するオプション。

## 実装戦略

### 一般的なワークフロー

**1. インテント認識:**  
NLUモデルを使用してインテントを検出し、適用されるスロットを識別します。

**2. エンティティ抽出:**  
エンティティ認識を適用して、ユーザー入力からスロット値を抽出します。

**3. スロット追跡:**  
会話全体を通じて、入力済み/未入力スロットの状態を維持します。

**4. プロンプトロジック:**  
未入力の必須スロットに対してユーザーに促すロジックを実装し、リトライや中断を管理します。

**5. スクリプト/コードアクセス:**  
会話スクリプトまたはバックエンドコードで入力済みスロットにアクセスします。

**6. 完了と確認:**  
すべての必須スロットが入力されたら、バックエンドアクションを実行する前にユーザーと確認することができます(オプション)。

**例:コードでのスロット抽出(疑似コード)**

```python
if not slots['city']:
    prompt("どの都市に旅行されますか?")
elif not slots['date']:
    prompt("いつ旅行されたいですか?")
else:
    confirm(f"{slots['date']}に{slots['city']}へのチケットを予約します。よろしいですか?")
```

### プラットフォーム固有の詳細

**Microsoft Copilot Studio:**
- 事前構築済みおよびカスタムエンティティを使用
- ファジーマッチングと自動修正のために「スマートマッチング」を有効化
- クローズドリストエンティティにシノニムを追加
- 構造化データ抽出のために正規表現を使用

**Just AI Conversational Cloud:**
- `chatbot.yaml`で必須/オプションスロット、配列型、リトライ/タイムアウトロジックを設定
- `$parseTree`または関連変数を介してスロットにアクセス

**Dydu:**
- スロット知識タイプを定義し、スロットフィリングプロセスを視覚的に設定
- 導入文、確認文、終了文を使用してユーザーフローを管理

## 実用例

### 例1:ピザの注文

**必須スロット:** スライス数、ピザのタイプ

```
ユーザー: 「ピザを注文したいです。」
ボット: 「何枚のスライスをご希望ですか?」
ユーザー: 「8枚」
ボット: 「どのタイプのピザをご希望ですか?」
ユーザー: 「ペパロニ」
ボット: 「8枚のペパロニピザですね。よろしいですか?」
ユーザー: 「はい」
ボット: 「注文が確定しました!」
```

### 例2:列車のチケット予約

**必須スロット:** 目的地都市、日付

```
ユーザー: 「パリ行きの列車のチケットを買いたいです。」
ボット: 「いつ旅行されたいですか?」
ユーザー: 「来週の月曜日。」
ボット: 「来週の月曜日のパリ行きチケットですね。進めてよろしいですか?」
```

### 例3:天気の問い合わせ

**スロット:** 都市(必須)、日付(オプション)

```
ユーザー: 「今日のロンドンの天気はどうですか?」
ボット: 「今日のロンドンの天気は晴れで20°Cです。」
```

日付が不足している場合:

```
ユーザー: 「パリの天気はどうですか?」
ボット: 「いつの予報が必要ですか?」
```

## ベストプラクティス

**1. 可能な限り組み込みエンティティを使用:**  
一般的なデータ型の堅牢な処理のために、プラットフォーム提供のエンティティを活用します。

**2. クローズドリストエンティティにシノニムを追加:**  
バリエーションや関連用語で認識を拡張します。

**3. スマートまたはファジーマッチングを有効化:**  
スペルミスや類似用語を許容してエンティティ認識を広げます。

**4. 正規表現を創造的に使用:**  
特にコードやIDの構造化データ形式にはRegExを使用します。

**5. 重要なスロット値を確認:**  
重要なアクションを実行する前に、常にユーザーと確認します。

**6. 最大リトライ/プロンプト制限を設定:**  
未入力スロットのプロンプトを制限することで、無限ループを防ぎます。

**7. 中断に対応した設計:**  
ユーザーがスロットフィリングフローを終了したり、トピックを優雅に切り替えられるようにします。

**8. 配列と複数のスロット値を処理:**  
ユーザーが同じスロットに複数の値を提供するシナリオをサポートします。

## よくある落とし穴と回避方法

**明確化質問の欠如:**  
必須スロットにプロンプトが指定されていない場合、インテントがマッチしない可能性があります。

**過度に厳格なエンティティ定義:**  
エンティティを狭いリストに制限しないでください。シノニムとスマートマッチングを使用します。

**スロットフィリング中断の未処理:**  
ユーザーが行き詰まった場合、スロットフィリングを放棄またはリセットする方法を常に提供します。

**確認ステップの無視:**  
スロット値を確認しないと、エラーやユーザーの不満につながる可能性があります。

**マルチターン/順不同入力の未サポート:**  
ユーザーは複数のメッセージにわたって任意の順序で情報を提供することを期待しています。

**最大リトライ/タイムアウトの未処理:**  
ユーザーを無限の明確化ループに閉じ込めないように、適切な制限を設定します。

## 高度なアプローチ:BERT

BERT(Bidirectional Encoder Representations from Transformers)は、深いコンテキスト言語理解を活用することで、スロットフィリングに革命をもたらしました:

**コンテキスト表現:** BERTは入力全体からコンテキストをキャプチャし、正確なスロット境界検出を支援します。

**曖昧性の解決:** ユーザークエリの曖昧な表現や略語を処理します。

**OOV処理:** サブワードトークン化により、ユーザーが稀な用語やスペルミスした用語を使用した場合でも抽出をサポートします。

**ファインチューニング:** 事前学習済みBERTモデルは、ドメイン適応のためにスロットフィリングデータセットでファインチューニングできます。

**実装ステップ:**

1. データ準備:ラベル付きデータセット(トークン+スロットラベル)を作成
2. BERTトークン化:テキストをトークン/サブワードに変換
3. モデルアーキテクチャ:BERTをエンコーダーとして使用し、スロット分類レイヤーを追加
4. ファインチューニング:クロスエントロピー損失を使用してスロットラベル付きデータで学習
5. 推論:ユーザー入力の各トークンのスロットラベルを予測

**Pythonの例:**

```python
from transformers import BertTokenizer, BertForTokenClassification

tokenizer = BertTokenizer.from_pretrained('bert-base-uncased')
model = BertForTokenClassification.from_pretrained('bert-base-uncased', num_labels=num_labels)

# トークン化してスロットを予測
inputs = tokenizer("Book a flight from New York to London", return_tensors='pt')
outputs = model(**inputs)
```

## 一般的なユースケース

スロットフィリングは、幅広い会話型AIアプリケーションを支えています:

**旅行予約:** 出発/到着都市、日付、乗客数、クラス

**Eコマース注文:** 製品タイプ、数量、サイズ、色、配送先住所

**カスタマーサポート:** チケット番号、アカウントID、問題の説明

**レストラン予約:** レストラン名、日付、時間、人数、特別なリクエスト

**スマートホーム/ユーティリティ:** デバイス名、アクション、スケジュール、設定

**ヘルスケアチャットボット:** 症状、予約日、医師名、保険情報

## よくある質問

**Q: スロットとエンティティの違いは何ですか?**  
スロットは、タスクを完了するために必要な特定の情報のプレースホルダー(例:チケット予約の「日付」)であり、エンティティはそのスロットを埋めることができるデータカテゴリーまたはタイプ(例:「都市」、「数値」、「日付」)です。

**Q: チャットボットはどのスロットを埋めるべきかをどのように知るのですか?**  
各インテントは必須およびオプションのスロットのセットに関連付けられています。チャットボットは、ユーザー入力と対話状態に基づいて、どれが入力されたかを追跡し、不足しているものを促します。

**Q: ユーザーが必要なスロット値をすべて提供しない場合はどうなりますか?**  
チャットボットは、最大リトライ制限に達するまで、またはユーザーがプロセスを放棄するまで、不足している必須スロットに対して明確化質問で促します。

**Q: ユーザーは1つのメッセージで複数のスロットを埋めることができますか?**  
はい。高度なNLUシステムは、単一のユーザー発話から複数のスロット値を抽出できます。

**Q: 複数の値を持つことができるスロットをどのように処理しますか?**  
複数の値を受け入れるために、スロットを「配列」に設定して構成します(例:1つの注文で複数のピザタイプ)。

## 重要なポイント

- スロットフィリングは、タスク指向会話型AIの基本であり、ボットがインテント実行に必要なすべてのデータを収集できるようにします
- インテント、スロット、エンティティの定義と、抽出のための堅牢なNLUに依存しています
- マルチターンで柔軟な対話と確認ステップにより、使いやすさと正確性が向上します
- ベストプラクティスには、組み込みエンティティの活用、シノニムとファジーマッチングの使用、適切なリトライ制限の設定が含まれます
- BERTのような最先端モデルにより、高度で高精度なスロット抽出が可能になります

## 参考文献


1. Microsoft. (n.d.). Use Entities and Slot Filling in Agents. Microsoft Copilot Studio.
2. Dydu. (n.d.). Slot Filling. Dydu Documentation.
3. Just AI. (n.d.). Slot Filling. Just AI Conversational Cloud.
4. Microsoft. (n.d.). Prebuilt Entities. Microsoft Copilot Studio.
5. Microsoft. (n.d.). Closed List Entities. Microsoft Copilot Studio.
6. Just AI. (n.d.). Entities Guide. Just AI.
7. Just AI. (n.d.). Slot Parameters. Just AI.
8. Dydu. (n.d.). Slot Configuration. Dydu.
9. Just AI. (n.d.). Slot Extraction. Just AI.
10. Just AI. (n.d.). Interruption of Slot Filling. Just AI.
11. Microsoft. (n.d.). Slot Filling Best Practices. Microsoft Copilot Studio.
12. Analytics Vidhya. (2023). Enhancing Conversational AI with BERT. Analytics Vidhya Blog.
