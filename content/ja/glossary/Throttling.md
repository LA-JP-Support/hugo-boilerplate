---
title: スロットリング(APIスロットリング)
date: '2025-12-19'
lastmod: '2025-12-19'
translationKey: throttling-api-throttling
description: スロットリング(APIスロットリングとも呼ばれる)は、特定の期間内にAPIやサービスへのリクエストを意図的に制限することです。過負荷を防ぎ、公平なアクセスを保証し、不正利用を抑制し、パフォーマンスを維持します。
keywords:
- APIスロットリング
- レート制限
- トークンバケット
- APIゲートウェイ
- システム保護
category: AI Infrastructure & Deployment
type: glossary
draft: false
e-title: Throttling (API Throttling)
term: スロットリング(エーピーアイスロットリング)
url: "/ja/glossary/Throttling/"
---
## スロットリング(APIスロットリング)とは?
スロットリング(APIスロットリングとも呼ばれる)とは、特定の期間内にユーザー、クライアント、またはアプリケーションがAPIやサービスに対して行えるリクエスト数を意図的に制限することです。スロットリングは、バックエンドの過負荷を防ぎ、公平なアクセスを確保し、悪用を抑制し、受信トラフィックのフローを管理・平準化することで一貫したサービスパフォーマンスを維持するために不可欠です。

その核心において、スロットリングはデジタルサービスのトラフィック制御メカニズムとして機能します。信号機が車両の流れを調整して渋滞を防ぐように、APIスロットリングはリクエストフローを管理してシステムの安定性と公平性を維持します。適切に実装されると、スロットリングは正当なユーザーには見えないものとなり、同時にインフラストラクチャを悪用、偶発的な誤用、意図的な攻撃から保護します。

現代のクラウドプラットフォームは、信頼性の高いスケーラブルなサービスを提供するためにスロットリングに大きく依存しています。AWSは、インフラストラクチャの過負荷を防ぐために、複数のシステムレベルでハードスロットリングとソフトスロットリングの両方を適用しています。Twitterなどのソーシャルプラットフォームは、スパムを制御しながらプラットフォームの安定性を維持するためにスロットリングを使用しています。AI APIは、高価なGPUリソースを管理し、すべてのユーザーに対して一貫した推論レイテンシを維持するためにスロットリングを活用しています。

## スロットリングが重要な理由

<strong>システム保護</strong>スロットリングは、パフォーマンスを低下させたり障害を引き起こす可能性のあるトラフィックスパイク、偶発的な誤用、または意図的な攻撃からバックエンドサービスを保護します。クラウドプロバイダーは、共有インフラストラクチャを保護するために多層的なスロットリング戦略を実装しています。AWSは、アカウント、サービス、リソースレベルで制限を適用し、単一のテナントがシステム容量を独占することを防ぎます。

<strong>公平な使用とリソース配分</strong>スロットリングは、単一のユーザーやクライアントがAPIリソースを独占できないことを保証し、すべての利用者に公平なアクセスを確保します。マルチテナント環境では、これにより「うるさい隣人」問題を防ぎます。これは、1人のユーザーの過度なアクティビティが他のユーザーのサービスを低下させる問題です。決済処理業者、予約システム、コラボレーションプラットフォームはすべて、サービス品質を維持するために公平使用スロットリングに依存しています。

<strong>セキュリティと攻撃防止</strong>スロットリングは、リクエストが受け入れられる速度を制限することで、悪意のある行為者がサービス拒否(DoS/DDoS)攻撃を開始する能力を制限します。レート制限は、ブルートフォースパスワード攻撃、クレデンシャルスタッフィング、列挙攻撃も軽減します。セキュリティに焦点を当てたスロットリングは、正当なトラフィックスパイクと攻撃パターンを区別し、悪用が検出されたときにより厳格な制限を適用できます。

<strong>パフォーマンスの安定性</strong>スロットリングは、変動の多いバースト性の負荷下でも予測可能で安定したAPI応答時間を維持します。トラフィックを平準化し、リソースの枯渇を防ぐことで、スロットリングは時間に敏感なアプリケーションに一貫したレイテンシを保証します。金融取引API、リアルタイムゲームサービス、IoTプラットフォームはすべて、スロットリングが保証する安定したパフォーマンスを必要とします。

<strong>収益化とサービス階層</strong>スロットリングは、無料プランと有料プランの使用量クォータを持つ差別化された価格設定とサービス階層を可能にします。SaaSプラットフォームは一般的に階層化されたアクセスを提供します:無料ユーザーは月1,000リクエストを受け取り、エンタープライズ顧客は無制限のアクセスを享受します。これにより、明確な価値の差別化と収益機会が生まれます。

<strong>リソース管理</strong>スロットリングは、需要を平準化し、同時ワークロードを制限することで、バックエンドリソース(データベース、キャッシュ、GPU、またはコンピューティング容量)の枯渇を防ぎます。AI推論APIは、高価なGPUリソースを管理し、コストを制御しながら効率的な利用を確保するためにスロットリングを使用します。

## 実世界のユースケース

<strong>ソーシャルメディアAPI</strong>Twitterは、スパムを抑制し、プラットフォームの安定性を保護するために、15分間のウィンドウごとにユーザーごとのAPI使用を制限しています。

<strong>予約エンジン</strong>オンライン旅行代理店は、上流のサービス中断を避けるために、航空会社予約システム(Sabre、Amadeus)への呼び出しをスロットリングします。

<strong>クラウドストレージ</strong>AWS S3は、すべてのテナントに一貫したパフォーマンスを維持するためにリクエストクォータを適用します。

<strong>AI API</strong>画像認識と大規模言語モデルAPIは、GPUコストを制御し、推論レイテンシを維持するために、ユーザーごとまたはアプリごとのスロットリングを適用します。

<strong>決済処理業者</strong>金融APIは、トランザクションのフラッディングを防ぎ、規制コンプライアンスを維持するために厳格なスロットリングを実装しています。

<strong>ゲームプラットフォーム</strong>マルチプレイヤーゲームサーバーは、不正行為を防ぎ、すべてのユーザーに公平なプレイを確保するためにリクエストをスロットリングします。

## スロットリングの仕組み

<strong>コアメカニズム</strong>

<strong>1. レート制限</strong>特定の時間ウィンドウ内でユーザー、クライアント、またはAPIキーごとに許可される最大リクエスト数を定義します(例:1時間あたり1,000リクエスト、1秒あたり10リクエスト)。

<strong>2. バースト制限</strong>しきい値まで持続レートを超える短いスパイクを許可します(例:1秒間に100リクエスト、平均は10/秒に制限)。バースト制限は、持続的な悪用を防ぎながら正当なトラフィックパターンに対応します。

<strong>3. エラー応答</strong>制限を超えると、HTTP `429 Too Many Requests`エラー応答がトリガーされ、クライアントに速度を落とすか後で再試行するよう通知します。

<strong>4. 再試行ガイダンス</strong>APIは、クライアントにいつ再試行すべきかを指示する`Retry-After`ヘッダーを返し、不要なトラフィックを防ぎ、インテリジェントなバックオフ戦略を可能にします。

<strong>5. 多層適用</strong>スロットリングは、ユーザーごと、APIキーごと、アプリケーションごと、リージョンごと、またはグローバルに複数のレベルで動作できます。APIゲートウェイは通常制限を適用しますが、バックエンドサービスが追加の制御を実装する場合もあります。

<strong>リクエストフロー</strong>1. <strong>クライアントリクエスト:</strong>クライアントがAPIエンドポイントにリクエストを送信
2. <strong>スロットルチェック:</strong>システムがトークンバケット、カウンター、またはキューを使用して、設定されたしきい値に対してリクエスト数とタイミングを検証
3. <strong>決定:</strong>制限内であればリクエストは続行され、超過している場合はシステムが関連ヘッダーとともに`429`エラーを返す
4. <strong>クライアント処理:</strong>クライアントがバックオフ戦略を実装—後続のリクエストを遅延、再試行、またはバッチ処理

<strong>HTTPレスポンスの例</strong>```http
HTTP/1.1 429 Too Many Requests
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 0
X-RateLimit-Reset: 1712345678
Retry-After: 60
Content-Type: application/json

{
  "error": "Rate limit exceeded. Please wait 60 seconds before retrying."
}
```

## スロットリングアルゴリズムとタイプ

**トークンバケットアルゴリズム**

**仕組み:**バケットが固定レートでトークンを蓄積します。各リクエストは1つのトークンを消費します。トークンが利用可能な場合にのみリクエストが処理され、持続的な平均レートを適用しながら短いバーストを許可します。

**特徴:**- **長所:**バーストを許可、柔軟な調整、簡単な実装
- **短所:**誤設定された容量は過度のスパイクを許可する可能性がある
- **類推:**水滴で満たされる水バケット;リクエストは水滴をすくい出す;空のバケットは補充を待つ必要がある

**実装例:**```python
def allow_request():
    now = current_time()
    bucket.tokens += (now - bucket.last_check) * bucket.refill_rate
    bucket.tokens = min(bucket.tokens, bucket.capacity)
    bucket.last_check = now
    if bucket.tokens >= 1:
        bucket.tokens -= 1
        return True
    return False
```

<strong>ユースケース:</strong>10/秒の持続レートで100リクエストのバーストを許可する株式市場API。

<strong>リーキーバケットアルゴリズム</strong>

<strong>仕組み:</strong>リクエストが固定サイズのキューに入ります。システムは一定のレートでリクエストを処理します。バケットがいっぱいになると、新しいリクエストはドロップまたは遅延されます。

<strong>特徴:</strong>- <strong>長所:</strong>バーストを平準化、安定した流出を確保
- <strong>短所:</strong>レイテンシを導入したり、正当なバースト性トラフィックをドロップする可能性がある
- <strong>類推:</strong>穴のあるバケット—水は任意のレートで入るが、一定のレートで漏れ出る

<strong>ユースケース:</strong>毎分100通のメールをキューに入れ、一定のレートで送信するメール送信API。

<strong>固定ウィンドウアルゴリズム</strong>

<strong>仕組み:</strong>固定間隔(例:分または時間ごと)内のリクエストをカウントします。カウンターはウィンドウの境界でリセットされます。

<strong>特徴:</strong>- <strong>長所:</strong>実装と理解が簡単
- <strong>短所:</strong>ウィンドウ境界でのバーストスパイクに脆弱

<strong>ユースケース:</strong>Twitterの15分間のウィンドウごとにユーザーあたり300リクエスト。

<strong>スライディングウィンドウアルゴリズム</strong>

<strong>仕組み:</strong>ローリング時間ウィンドウ(例:過去60秒)内のリクエストを追跡し、より細かい制御とバースト平準化を実現します。

<strong>特徴:</strong>- <strong>長所:</strong>境界バースト性を防ぎ、よりスムーズな適用を提供
- <strong>短所:</strong>タイムスタンプ追跡が必要、より複雑な実装

<strong>ユースケース:</strong>ローリング60秒期間ごとに100リクエストを許可するSaaS API。

<strong>同時リクエスト制限</strong>

<strong>仕組み:</strong>タイミングに関係なく、クライアントごとの同時進行中リクエスト数を制限します。

<strong>特徴:</strong>- <strong>長所:</strong>並列ワークロードからのリソース枯渇を防ぐ
- <strong>短所:</strong>時間経過に伴う総リクエスト量を制御しない

<strong>ユースケース:</strong>クライアントごとに最大5つの同時リクエストを許可する画像処理API。

<strong>ハードスロットリング vs ソフトスロットリング</strong>

<strong>ハードスロットリング:</strong>超過リクエストが即座に拒否される厳格な適用。無料APIティアと重要なインフラストラクチャ保護に使用されます。

<strong>ソフトスロットリング:</strong>バックエンド容量に基づいて一時的な超過を許可したり、超過リクエストをキューに入れたりします。重要な顧客や一時的なスパイクに柔軟性を提供します。

<strong>ユーザーレベル vs システムレベルスロットリング</strong>

<strong>ユーザーレベル:</strong>公平性を確保するために、個々のユーザー、クライアント、またはAPIキーごとの制限。

<strong>システムレベル:</strong>個々のユーザーに関係なく、全体的なインフラストラクチャの健全性を保護するグローバル制限。

## アルゴリズム比較

| アルゴリズム | バースト許可 | 厳格な制限 | 複雑さ | 最適なユースケース |
|-----------|:-------------:|:------------:|:----------:|---------------|
| トークンバケット | はい | いいえ | 中 | 取引API、クラウドサービス |
| リーキーバケット | いいえ | はい | 中 | メール送信者、Webクローラー |
| 固定ウィンドウ | はい(エッジで) | はい | 低 | ソーシャルメディアAPI、天気サービス |
| スライディングウィンドウ | やや | はい | 高 | SaaSプラットフォーム、マイクロサービス |
| 同時制限 | N/A | はい | 低 | データベース接続、GPUワークロード |

## 実装のベストプラクティス

<strong>きめ細かい制限の設計</strong>

<strong>多層制御:</strong>- ユーザー、APIキー、エンドポイント、リージョンレベルで制限を設定
- 複数の時間ウィンドウを使用:秒、分、時間、日ごと
- 機密操作に対してメソッド固有の制限を実装

<strong>例:</strong>AWS API Gatewayは、独立した設定でクライアントごと、メソッドごと、ステージごとのスロットリングをサポートしています。

<strong>分散カウンターの使用</strong>

<strong>集中追跡:</strong>分散システムでは、正確なカウンター管理のためにRedisなどの集中ストアを使用します。マルチノード環境でのローカルカウンターは、不正確な適用と潜在的な過負荷をもたらします。

<strong>明確なエラーメッセージの提供</strong>

<strong>必須ヘッダー:</strong>- `X-RateLimit-Limit`: 許可される最大リクエスト数
- `X-RateLimit-Remaining`: 現在のウィンドウでの残りクォータ
- `X-RateLimit-Reset`: クォータがリセットされるUnixタイムスタンプ
- `Retry-After`: 再試行前に待機する秒数

<strong>明確なボディメッセージ:</strong>制限を説明し、次のステップを提案する人間が読めるエラーメッセージを含めます。

<strong>インテリジェントな再試行戦略の有効化</strong>

<strong>クライアントガイダンス:</strong>クライアントにジッターを伴う指数バックオフを実装するようアドバイスし、制限がリセットされたときのサンダリングハード問題を防ぎます。

<strong>パターン例:</strong>```python
delay = min(max_delay, base_delay * (2 **attempt) + random_jitter())
```

**APIゲートウェイ統合の活用**

**集中管理:**AWS API Gateway、Kong、Graviteeなどのプラットフォームを使用して、集中ポリシー管理、分析、動的制限調整を行います。

**メリット:**- すべてのサービスにわたる統一されたスロットリング
- リアルタイム監視とアラート
- 負荷に基づく動的調整
- 組み込みの分析とレポート

**継続的な監視と調整**

**可観測性:**- 使用パターン、エラー率、システムヘルスを追跡
- 429レスポンス頻度を監視
- クライアントの動作とトラフィックパターンを分析
- 実際の容量と使用状況に基づいてしきい値を調整

**透明性の維持**

**ドキュメント:**- スロットリングポリシーを明確に文書化
- 可能な場合は使用ダッシュボードを提供
- ポリシー変更を事前に通知
- セルフサービスクォータ管理を提供

## よくある落とし穴と解決策

**不適切な制限設定**

**問題:**制限が低すぎると正当なユーザーをブロックし、エクスペリエンスを損ないます。制限が高すぎるとバックエンドインフラストラクチャを保護できません。

**解決策:**負荷テストを実施して現実的なしきい値を調整します。保守的に開始し、観察された使用パターンと容量に基づいて調整します。

**不十分な監視**

**問題:**リアルタイム分析がないと、重大な障害が発生するまで悪用やパフォーマンス低下に気付きません。

**解決策:**異常なパターンに対するアラートを含む包括的な監視を実装します。レート制限ヒットと全体的なシステムヘルスの両方を追跡します。

**不明確なエラー処理**

**問題:**曖昧または欠落している`429`レスポンスは、API利用者を混乱させ、再試行ストームを引き起こします。

**解決策:**常に完全なレート制限ヘッダーと明確で実行可能なエラーメッセージを含めます。

**ドキュメントの欠如**

**問題:**文書化されていないスロットリングポリシーは開発者を苛立たせ、予測不可能なアプリケーション障害を引き起こします。

**解決策:**明確でアクセス可能なドキュメントを維持します。例とベストプラクティスを含めます。

**再試行ガイダンスの欠如**

**問題:**`Retry-After`ヘッダーがないと、不要なトラフィックと不適切なクライアント動作につながります。

**解決策:**常に正確なクールダウン期間を含む`Retry-After`を含めます。指数バックオフに関するガイダンスを提供します。

**分散システムの無視**

**問題:**マルチノード環境でのローカルカウンターは、不正確な適用と潜在的な過負荷をもたらします。

**解決策:**すべてのノードにわたる適切な同期を伴う集中的でアトミックなカウンターを使用します。

## よくある質問

**Q: スロットリング制限を超えるとどうなりますか?**A: APIはHTTP `429 Too Many Requests`をクールダウン期間を示すヘッダーとともに返します。クライアントは再試行する前に指定された期間待機する必要があります。

**Q: クライアントはスロットリング制限に達することをどのように回避できますか?**A: バッチ処理とキャッシングを通じてリクエストパターンを最適化し、レート制限ヘッダーを監視し、ジッターを伴う指数バックオフを実装し、正当なニーズが制限を超える場合はクォータの増加を要求します。

**Q: スロットリングとレート制限の違いは何ですか?**A: レート制限はポリシーとリクエスト上限を定義します;スロットリングは、システムヘルスを維持するためにリクエストを拒否または遅延させる適用メカニズムです。これらの用語はしばしば互換的に使用されます。

**Q: スロットリングは動的にできますか?**A: はい、動的スロットリングは、リアルタイムのサーバー負荷、時刻、またはユーザー動作に基づいて制限を適応させます。ただし、実装はより複雑で、高度な監視が必要です。

**Q: エラー応答はどのように構造化すべきですか?**A: HTTP `429`をヘッダー(`X-RateLimit-Limit`、`X-RateLimit-Remaining`、`X-RateLimit-Reset`、`Retry-After`)とともに返し、エラーを説明し再試行タイミングを提案する明確なJSONボディを含めます。

**Q: スロットリングはすべてのユーザーに平等に影響しますか?**A: 必ずしもそうではありません。階層化されたスロットリングは、サブスクリプションレベル、ユーザータイプ、またはサービスプランに基づいて異なる制限を適用し、インフラストラクチャを保護しながら収益化を可能にします。

**Q: 適切なスロットリングアルゴリズムをどのように選択しますか?**A: トラフィックパターン、ビジネス要件、技術的制約を考慮してください。トークンバケットはバースト性トラフィックを持つAPIに適しており、リーキーバケットは安定した出力レートを必要とするシナリオに適しています。

## シナリオ例:AIインフラストラクチャスロットリング

ある企業が、以下のスロットリング制御を持つ公開AI画像認識APIを運用しています:

**トークンバケット設定:**- 容量:50リクエスト(バーストを許可)
- 補充レート:5リクエスト/秒(持続レート)

**同時リクエスト制限:**- クライアントごとに最大10の進行中リクエスト
- 並列処理からのGPU過負荷を防ぐ

**システムレベル保護:**- GPU クラスター全体にわたるグローバル上限
- 集約負荷下でのインフラストラクチャ安定性を確保

**エラー処理:**- `Retry-After`ヘッダーとともに`429`を返す
- 分析と容量計画のために使用状況を追跡
- 異常なパターンに対してアラート

**結果:**システムは、悪用を防ぎながらトラフィックスパイクを優雅に処理し、一貫したレイテンシを維持し、高価なGPUリソースを保護します。

## 重要なポイント

- スロットリングはAPIを保護し、信頼性を維持しながら公平性を確保します
- 複数のアルゴリズムが異なるユースケースとトラフィックパターンに適しています
- 実装には、堅牢なエラー処理、明確なコミュニケーション、継続的な監視が必要です
- APIゲートウェイはスロットリング適用を集中化およびスケールします
- 適切な調整は保護とユーザーエクスペリエンスのバランスを取ります
- 透明性とドキュメントは開発者満足度に不可欠です

## 参考文献


1. AWS. (n.d.). Throttle API Requests for Better Throughput. AWS Documentation.

2. Gravitee. (n.d.). API Throttling Best Practices. Gravitee Blog.

3. Knit.dev. (n.d.). 10 Best Practices for API Rate Limiting and Throttling. Knit.dev Blog.

4. IETF. (n.d.). RFC 6585: Additional HTTP Status Codes. IETF Datatracker.

5. Twitter. (n.d.). Twitter API Rate Limits. Twitter Developer Documentation.

6. AWS. (n.d.). S3 Performance Optimization. AWS Documentation.

7. TIBCO. (n.d.). What is API Throttling?. TIBCO Glossary.

8. GetStream. (n.d.). API Throttling Glossary. GetStream Glossary.

9. YouTube. (n.d.). What is Rate Limiting / API Throttling?. YouTube.

10. Gravitee. (n.d.). Gravitee API Gateway Platform. Gravitee Platform.
