---
title: "Speculative Decoding"
date: 2025-12-18
lastmod: 2025-12-18
translationKey: "speculative-decoding"
description: "A technique that speeds up AI text generation by having a smaller model quickly propose multiple tokens while a larger model verifies them, delivering results 2-3x faster without losing quality."
keywords: ["speculative decoding", "LLM inference", "draft model", "target model", "latency reduction"]
category: "AI Infrastructure & Deployment"
type: "glossary"
draft: false
---

## What is Speculative Decoding?

Speculative decoding is an inference optimization technique for large language models (LLMs) that enables faster token generation by leveraging a small, fast draft model to propose multiple tokens ahead of time, while a larger, accurate target model verifies the draft and accepts the longest matching prefix. This process maintains the target model's output distribution, ensuring that the results are mathematically identical to pure sequential decoding, but with much lower latency.

The key insight is that many tokens in LLM output sequences can be guessed correctly by a much smaller model, and verifying a batch of tokens together with the large model is more efficient than generating each token in strict sequence.

Speculative decoding is structured as a <strong>draft-then-verify</strong>process that maintains the exact output quality of the target model while achieving 2–3x+ latency reduction in production systems.

## How Speculative Decoding Works

### Draft-Then-Verify Process

<strong>1. Draft Step</strong>The draft model, which is a smaller and faster LLM, generates a batch of candidate next tokens (often 3–8 at a time). This model is designed to "guess ahead," producing tokens that the target model is likely to accept.

<strong>2. Verification Step</strong>The large, accurate target model evaluates the same context (input plus all generated tokens so far) and computes the probability distributions for the next batch of tokens. The target model checks which draft tokens match its own most probable next-token predictions. It accepts the longest matching prefix, which could be all, some, or none of the draft tokens.

<strong>3. Continuation</strong>If the draft is fully accepted, output continues. If there is a mismatch, the target model generates the next token itself, which becomes the new context for the next speculative round.

<strong>4. Repeat</strong>This process continues until the output sequence is complete.

<strong>Guarantee:</strong>The final output is provably identical to what the target model would produce via naïve, sequential decoding.

## Core Terminology

<strong>Autoregressive Generation:</strong>Generating tokens one at a time, with each depending on all previous tokens. This is the standard for LLMs like GPT, T5, Llama.

<strong>Draft Model:</strong>Small, fast model used to propose candidate tokens in advance. Should be trained or fine-tuned to match the output distribution of the target model as closely as possible.

<strong>Target Model:</strong>The large, accurate LLM whose output must be preserved exactly.

<strong>Draft Tokens:</strong>Batch of tokens guessed by the draft model for the next sequence positions.

<strong>Rejection Sampling:</strong>Statistical mechanism whereby the target model accepts only those draft tokens that match its own most probable predictions, thus preserving the target's output distribution.

<strong>Acceptance Rate (α):</strong>Fraction of draft tokens accepted by the target model. High α means the draft model is well aligned to the target model.

<strong>Speculative Token Count (γ):</strong>Number of tokens generated by the draft model in each speculative round.

<strong>Acceptance Length (τ):</strong>Average number of draft tokens accepted per speculative round: τ = (1 - α^(γ+1)) / (1 - α)

<strong>Inter-Token Latency (ITL):</strong>Time between emitting one output token and the next.

<strong>EAGLE-3:</strong>An advanced speculative decoding technique that attaches a lightweight prediction head to the internal layers of the target model itself, eliminating the need for a separate draft model.

## Motivation

### LLM Inference Bottleneck

<strong>Problem:</strong>- Generating each new token requires a full forward pass through the entire target model, which is slow (especially for models >10B parameters)
- This sequential dependency results in high latency and underutilization of parallel compute in modern GPUs

<strong>Solution:</strong>- By allowing a draft model to "guess ahead" and only invoking the large model for verification, token generation can be parallelized
- This reduces overall latency, increases throughput, and enables more responsive LLM-powered applications (chatbots, code assistants, real-time summarization)

<strong>Industry Need:</strong>Real-world products such as Google Search's AI Overviews rely on speculative decoding to serve billions of users with high-quality, low-latency results.

## Core Algorithm

### Pseudocode

```python
context = input_tokens
while not finished:
    draft_tokens = draft_model.generate(context, num_tokens=γ)
    target_distributions = target_model.predict(context, num_tokens=γ)
    accepted = []
    for i in range(γ):
        if draft_tokens[i] == argmax(target_distributions[i]):
            accepted.append(draft_tokens[i])
        else:
            break
    context += accepted
    next_token = target_model.generate(context, num_tokens=1)
    context.append(next_token)
    if next_token == stop_token:
        finished = True
```

### Detailed Algorithm

<strong>1. Initialization:</strong>The target model generates the first token using standard decoding.

<strong>2. Draft:</strong>The draft model receives the current context and proposes γ tokens.

<strong>3. Verification:</strong>The target model computes the probability distribution over the next γ tokens and compares with the draft's proposal. Accepts the longest prefix of matching tokens. If a mismatch occurs, stops accepting further draft tokens.

<strong>4. Target Token Generation:</strong>After accepting h tokens (h ≤ γ), the target model produces the next token.

<strong>5. Repeat:</strong>Context is updated and the process continues until the sequence ends.

## Performance Metrics

### Key Metrics

<strong>Acceptance Rate (α):</strong>α = (number of accepted draft tokens) / (number of tokens proposed by draft model)

<strong>Speculative Token Count (γ):</strong>Number of tokens proposed per speculative round. Tuning γ impacts speedup and resource use.

<strong>Acceptance Length (τ):</strong>Average number of draft tokens accepted per speculative round

<strong>Inter-Token Latency (ITL):</strong>Time between generated tokens

<strong>Throughput:</strong>Number of tokens generated per second

### Practical Example

Suppose:
- Target model generation: 10 ms/token
- Draft model: 1 ms for γ=4 tokens
- Target verification: 1 ms for γ=4 tokens

If average of 2.5 draft tokens are accepted per round, then in 15 ms (1 ms draft, 1 ms verify, 10 ms for non-accepted token), you get 3.5 tokens.

<strong>Effective token time:</strong>≈4.3 ms/token (vs. 10 ms/token baseline)

### Key Factors

<strong>Draft Model Alignment:</strong>Higher acceptance rates come from draft models whose output distribution closely matches the target model's.

<strong>Model Size/Architecture:</strong>Larger models benefit more from speculative decoding; the draft model should be significantly faster, but not so small that it poorly predicts the target.

<strong>Hardware Constraints:</strong>Both models and their key-value caches must fit in memory.

<strong>Batch Size:</strong>Speculative decoding is most effective at low batch sizes (latency-critical applications).

<strong>Orchestration Overhead:</strong>Efficient communication and scheduling between models is critical.

## Benefits

<strong>2–3x+ Latency Reduction:</strong>Empirically demonstrated speedups in Google products and academic benchmarks.

<strong>Guaranteed Output Quality:</strong>Outputs are mathematically identical to target model sequential decoding.

<strong>Better Hardware Utilization:</strong>Unlocks latent compute power on GPUs/TPUs by batching token checks.

<strong>No Retraining Required:</strong>Any pre-trained models can be used as draft/target, though fine-tuning the draft for higher α is beneficial.

<strong>Lower Serving Costs:</strong>Fewer machines required for the same throughput.

<strong>Used in Major Production Systems:</strong>Google Search AI Overviews, code assistants, summarization tools.

## Limitations and Caveats

<strong>Increased Memory Use:</strong>Both models (with caches) must fit in memory, reducing batch size.

<strong>Throughput Tradeoffs:</strong>At high batch sizes, speculative decoding may not improve and may even decrease throughput due to contention.

<strong>Waste if Draft is Poorly Aligned:</strong>If acceptance rate is low (e.g., <0.5), speculative decoding adds overhead without speedup.

<strong>Model Compatibility Constraints:</strong>Draft and target should use the same tokenizer and similar architectures for best results.

<strong>Orchestration Complexity:</strong>Requires careful engineering for efficient model interaction and cache management.

<strong>Less Effective for Small Models or High Batch Loads:</strong>Speedup is most pronounced for large models and latency-sensitive applications.

## Implementation Guidance

### When to Use Speculative Decoding

<strong>Latency-Critical Applications:</strong>Chatbots, code completion, real-time summarization.

<strong>Large Models:</strong>>10B parameters, where per-token latency is highest.

<strong>Low to Moderate Batch Sizes:</strong>Where user-facing latency is more important than throughput.

### When to Avoid

<strong>GPU Memory Maxed Out:</strong>Large batch sizes, long context windows.

<strong>Low Draft Acceptance Rate:</strong>If draft model struggles to mimic the target.

<strong>Small LLMs:</strong>Marginal gain does not justify complexity.

### Configuration & Tuning

<strong>Draft Model Selection:</strong>Start with a smaller version of your target, fine-tune if possible.

<strong>Speculative Token Count (γ):</strong>Typical: 3–8 per round. Tune for your workload.

<strong>Acceptance Rate Monitoring:</strong>Track α in production. If α < 0.6, consider tuning or fallback.

<strong>Memory Management:</strong>Monitor GPU memory; use quantization or split models if needed.

### Example: vLLM Python API

```python
from vllm import LLM, SamplingParams

llm = LLM(model="your-target-model", draft_model="your-draft-model")
params = SamplingParams(max_tokens=100, speculative_tokens=4)
output = llm.generate("Prompt text", sampling_params=params)
print(output)
```

## Use Cases and Examples

### Real-World Deployments

<strong>Google Search AI Overviews:</strong>Powers high-quality, low-latency summaries for billions of users.

<strong>Code Generation Tools:</strong>Used by IDE assistants for fast code completion.

<strong>Enterprise Chatbots:</strong>Improves user experience and reduces serving cost for high-volume customer support.

<strong>Batch Translation/Summarization:</strong>Enables fast output for long documents with high per-sample latency.

### Research Benchmarks

<strong>T5-XXL (11B) with T5-small (60M):</strong>Shows 2–3x speedup on translation tasks.

<strong>Llama 70B:</strong>Reports significant latency improvements with speculative decoding.

## Best Practices and Tuning

<strong>1. Draft Model Selection:</strong>Use a smaller model from the same family and tokenizer; fine-tune for your use-case if possible.

<strong>2. Tune γ:</strong>Start with γ=3–5, increase if α remains high.

<strong>3. Monitor α:</strong>If α drops below 0.5, reduce γ or re-align draft model.

<strong>4. Optimize Memory:</strong>Use quantization, multi-GPU, or reduce batch/context if needed.

<strong>5. Benchmark:</strong>Test under real workload and hardware.

<strong>6. Automate Fallback:</strong>Disable speculative decoding if α or memory pressure crosses thresholds.

## Open Source Tools and Frameworks

<strong>vLLM:</strong>High-throughput LLM inference engine with speculative decoding.

<strong>BentoML:</strong>Guides and framework integration.

<strong>Modular MAX:</strong>Out-of-the-box support via config.

<strong>TensorRT-LLM (Baseten):</strong>High-performance deployment with speculative decoding.

## References


1. Google Research. (n.d.). Looking Back at Speculative Decoding. Google Research Blog.

2. Anonymous. (2022). Fast Inference from Transformers via Speculative Decoding. arXiv.

3. NVIDIA. (n.d.). An Introduction to Speculative Decoding. NVIDIA Technical Blog.

4. BentoML. (n.d.). Speculative Decoding. URL: https://bentoml.com/llm/inference-optimization/speculative-decoding

5. Baseten. (n.d.). A Quick Introduction to Speculative Decoding. Baseten Blog.

6. Stern et al. (2018). Speculative Sampling. arXiv.

7. Anonymous. (2023). Distributed Speculative Decoding. arXiv.

8. vLLM. (n.d.). Speculative Decoding. vLLM Documentation.

9. BentoML. (n.d.). Structured Decoding in vLLM. BentoML Blog.

10. Modular MAX. (n.d.). Speculative Decoding Documentation. URL: https://docs.modular.com/max/serve/speculative-decoding

11. vLLM Project. (n.d.). vLLM Project. URL: https://github.com/vllm-project/vllm
