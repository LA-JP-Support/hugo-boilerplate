{{ define "main" }}
<style>
  /* Antigravity Hero Styles */
  @keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
  }
  @keyframes float {
    0%, 100% { transform: translate(0px, 0px); }
    25% { transform: translate(30px, -50px); }
    50% { transform: translate(-20px, -100px); }
    75% { transform: translate(-50px, -50px); }
  }
  @keyframes pulse {
    0%, 100% { opacity: 0.6; }
    50% { opacity: 1; }
  }
  @keyframes slideInDown {
    from { opacity: 0; transform: translateY(-50px); }
    to { opacity: 1; transform: translateY(0); }
  }
  @keyframes slideInUp {
    from { opacity: 0; transform: translateY(50px); }
    to { opacity: 1; transform: translateY(0); }
  }
  
  .antigravity-hero {
    background: linear-gradient(135deg, 
      #2a3d78 0%, 
      #3a2d65 25%, 
      #8b4db5 50%, 
      #2d6da4 75%, 
      #0097a9 100%);
    background-size: 400% 400%;
    animation: gradientShift 12s ease infinite;
    min-height: 70vh;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  
  /* Background Image Layer with darker overlay */
  .hero-background-image {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }
  
  .hero-background-image::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    z-index: 1;
  }
  
  .hero-background-image img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    opacity: 0.45;
    mix-blend-mode: overlay;
  }
  
  .dark .hero-background-image img {
    opacity: 0.35;
  }
  
  /* Floating Orbs */
  .antigravity-hero::before {
    content: '';
    position: absolute;
    top: -10%;
    left: -5%;
    width: 500px;
    height: 500px;
    background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
    border-radius: 50%;
    animation: float 25s ease-in-out infinite;
    filter: blur(60px);
    z-index: 2;
  }
  
  .antigravity-hero::after {
    content: '';
    position: absolute;
    bottom: -10%;
    right: -5%;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
    border-radius: 50%;
    animation: float 30s ease-in-out infinite reverse;
    filter: blur(60px);
    z-index: 2;
  }
  
  /* Particle Canvas */
  #particles-canvas {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 3;
  }
  
  /* Glow Effect */
  .hero-glow {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 4;
  }
  
  .hero-glow-orb {
    position: absolute;
    width: 400px;
    height: 400px;
    background: radial-gradient(circle, rgba(255, 255, 255, 0.12) 0%, transparent 70%);
    border-radius: 50%;
    filter: blur(80px);
    transform: translate(-50%, -50%);
    transition: left 0.1s ease-out, top 0.1s ease-out;
    animation: pulse 3s ease-in-out infinite;
  }
  
  /* Content */
  .hero-content {
    position: relative;
    z-index: 10;
    text-shadow: 0 4px 20px rgba(0,0,0,0.5);
  }
  
  .hero-content h1 {
    animation: slideInDown 0.8s ease-out;
  }
  
  .hero-content p {
    animation: slideInUp 0.8s ease-out 0.1s both;
  }
  
  .hero-content .cta-buttons {
    animation: slideInUp 0.8s ease-out 0.2s both;
  }
  
  /* Dark mode adjustments */
  .dark .antigravity-hero {
    background: linear-gradient(135deg, 
      #0a0f2f 0%, 
      #12102d 25%, 
      #2a1a4b 50%, 
      #06344a 75%, 
      #023a3a 100%);
  }
</style>

<div class="antigravity-hero">
  <!-- Background Image (darker) -->
  <div class="hero-background-image">
    <img src="/images/a_modern_customer_support.jpg" alt="Customer Support Background" loading="eager">
  </div>
  
  <!-- Particle Canvas -->
  <canvas id="particles-canvas"></canvas>
  
  <!-- Glow Effect -->
  <div class="hero-glow" id="heroGlow">
    <div class="hero-glow-orb" id="heroGlowOrb"></div>
  </div>
  
  <!-- Content -->
  <div class="relative isolate z-10 w-full">
    <div class="wrapper py-16 sm:py-20">
      <div class="hero-content mx-auto max-w-3xl text-center">
        <!-- Main Heading -->
        {{ if .Params.hero_heading }}
          <h1 class="text-5xl font-semibold tracking-tight text-balance text-white drop-shadow-lg sm:text-7xl">
            {{ .Params.hero_heading }}
          </h1>
        {{ else }}
          <h1 class="text-5xl font-semibold tracking-tight text-balance text-white drop-shadow-lg sm:text-7xl">
            {{ .Title }}
          </h1>
        {{ end }}

        <!-- Description (Pure White) -->
        {{ if .Params.hero_description }}
          <p class="mt-9 text-lg font-medium text-pretty text-white drop-shadow-md sm:text-xl/8">
            {{ .Params.hero_description | safeHTML }}
          </p>
        {{ else if .Description }}
          <p class="mt-9 text-lg font-medium text-pretty text-white drop-shadow-md sm:text-xl/8">
            {{ .Description }}
          </p>
        {{ end }}

        <!-- CTA Buttons -->
        {{ if or .Params.cta_primary .Params.cta_secondary }}
          <div class="cta-buttons mt-9 flex flex-wrap items-center justify-center gap-x-6 gap-y-4">
            {{ if .Params.cta_primary }}
              <a href="{{ .Params.cta_primary.url }}" 
                 class="rounded-md bg-white px-4 py-2.5 text-sm font-semibold text-indigo-600 shadow-lg hover:bg-gray-50 focus-visible:outline focus-visible:outline-2 focus-visible:outline-offset-2 focus-visible:outline-white transition-all hover:scale-105">
                {{ .Params.cta_primary.text }}
              </a>
            {{ end }}
            {{ if .Params.cta_secondary }}
              <a href="{{ .Params.cta_secondary.url }}" 
                 class="text-sm font-semibold text-white hover:text-white/80 transition-colors drop-shadow-md">
                {{ .Params.cta_secondary.text }} <span aria-hidden="true">â†’</span>
              </a>
            {{ end }}
          </div>
        {{ end }}

        <!-- Hero Image -->
        {{ if .Params.hero_image }}
          <div class="mt-16 flow-root sm:mt-20">
            <div class="rounded-xl bg-white/10 backdrop-blur-sm p-2 ring-1 ring-inset ring-white/20 lg:-m-4 lg:rounded-2xl lg:p-4">
              <img src="{{ .Params.hero_image }}" 
                   alt="{{ .Params.hero_image_alt | default "Hero Image" }}" 
                   class="w-full rounded-md shadow-2xl ring-1 ring-white/10">
            </div>
          </div>
        {{ end }}
      </div>
    </div>
  </div>
  
  <script>
  (function() {
    'use strict';
    
    // Content Section Floating Particles
    class ContentParticleSystem {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.particles = [];
        this.particleCount = 30;
        this.mouse = { x: null, y: null, radius: 180 };
        
        this.init();
        this.animate();
        this.setupEventListeners();
      }
      
      init() {
        this.resize();
        this.createParticles();
      }
      
      resize() {
        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
      }
      
      createParticles() {
        this.particles = [];
        for (let i = 0; i < this.particleCount; i++) {
          this.particles.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            radius: Math.random() * 2 + 0.8,
            vx: (Math.random() - 0.5) * 0.25,
            vy: (Math.random() - 0.5) * 0.25,
            opacity: Math.random() * 0.3 + 0.15,
            wobbleSpeed: Math.random() * 0.015 + 0.008,
            wobbleAmount: Math.random() * 1.5 + 0.8,
            wobbleOffset: Math.random() * Math.PI * 2
          });
        }
      }
      
      drawParticles() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.particles.forEach((particle, i) => {
          particle.wobbleOffset += particle.wobbleSpeed;
          const wobbleX = Math.sin(particle.wobbleOffset) * particle.wobbleAmount;
          const wobbleY = Math.cos(particle.wobbleOffset * 1.5) * particle.wobbleAmount;
          
          particle.x += particle.vx + wobbleX * 0.1;
          particle.y += particle.vy + wobbleY * 0.1;
          
          if (this.mouse.x !== null && this.mouse.y !== null) {
            const rect = this.canvas.getBoundingClientRect();
            const mouseX = this.mouse.x - rect.left;
            const mouseY = this.mouse.y - rect.top;
            
            const dx = mouseX - particle.x;
            const dy = mouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < this.mouse.radius) {
              const force = (this.mouse.radius - distance) / this.mouse.radius;
              const angle = Math.atan2(dy, dx);
              particle.vx -= Math.cos(angle) * force * 0.3;
              particle.vy -= Math.sin(angle) * force * 0.3;
            }
          }
          
          particle.vx *= 0.98;
          particle.vy *= 0.98;
          
          if (particle.x < 0 || particle.x > this.canvas.width) {
            particle.vx *= -0.8;
            particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
          }
          if (particle.y < 0 || particle.y > this.canvas.height) {
            particle.vy *= -0.8;
            particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
          }
          
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          this.ctx.fillStyle = `rgba(99, 102, 241, ${particle.opacity})`;
          this.ctx.shadowBlur = 6;
          this.ctx.shadowColor = `rgba(99, 102, 241, ${particle.opacity * 0.6})`;
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
          
          this.particles.slice(i + 1).forEach(otherParticle => {
            const dx = particle.x - otherParticle.x;
            const dy = particle.y - otherParticle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 100) {
              this.ctx.beginPath();
              this.ctx.strokeStyle = `rgba(99, 102, 241, ${0.12 * (1 - distance / 100)})`;
              this.ctx.lineWidth = 0.5;
              this.ctx.moveTo(particle.x, particle.y);
              this.ctx.lineTo(otherParticle.x, otherParticle.y);
              this.ctx.stroke();
            }
          });
        });
      }
      
      animate() {
        this.drawParticles();
        this.animationId = requestAnimationFrame(() => this.animate());
      }
      
      setupEventListeners() {
        window.addEventListener('resize', () => {
          this.resize();
          this.createParticles();
        });
        
        const mouseMoveHandler = (e) => {
          this.mouse.x = e.clientX;
          this.mouse.y = e.clientY;
        };
        
        const mouseLeaveHandler = () => {
          this.mouse.x = null;
          this.mouse.y = null;
        };
        
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseleave', mouseLeaveHandler);
        
        this.cleanupListeners = () => {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseleave', mouseLeaveHandler);
        };
      }
      
      destroy() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
        if (this.cleanupListeners) {
          this.cleanupListeners();
        }
      }
    }
    
    function initContentParticles() {
      const canvas = document.getElementById('content-particles-canvas');
      if (canvas && !canvas.particleSystem) {
        canvas.particleSystem = new ContentParticleSystem(canvas);
      }
    }
    
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initContentParticles);
    } else {
      initContentParticles();
    }
  })();
  </script>
  
  <script>
  (function() {
    'use strict';
    
    // Features Section Floating Particles (Drone-like)
    class FeaturesParticleSystem {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.particles = [];
        this.particleCount = 40;
        this.mouse = { x: null, y: null, radius: 180 };
        
        this.init();
        this.animate();
        this.setupEventListeners();
      }
      
      init() {
        this.resize();
        this.createParticles();
      }
      
      resize() {
        this.canvas.width = this.canvas.offsetWidth;
        this.canvas.height = this.canvas.offsetHeight;
      }
      
      createParticles() {
        this.particles = [];
        for (let i = 0; i < this.particleCount; i++) {
          this.particles.push({
            x: Math.random() * this.canvas.width,
            y: Math.random() * this.canvas.height,
            radius: Math.random() * 2.5 + 1,
            vx: (Math.random() - 0.5) * 0.3,
            vy: (Math.random() - 0.5) * 0.3,
            opacity: Math.random() * 0.4 + 0.2,
            // Drone-like wobble
            wobbleSpeed: Math.random() * 0.02 + 0.01,
            wobbleAmount: Math.random() * 2 + 1,
            wobbleOffset: Math.random() * Math.PI * 2
          });
        }
      }
      
      drawParticles() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        this.particles.forEach((particle, i) => {
          // Drone-like floating motion
          particle.wobbleOffset += particle.wobbleSpeed;
          const wobbleX = Math.sin(particle.wobbleOffset) * particle.wobbleAmount;
          const wobbleY = Math.cos(particle.wobbleOffset * 1.5) * particle.wobbleAmount;
          
          particle.x += particle.vx + wobbleX * 0.1;
          particle.y += particle.vy + wobbleY * 0.1;
          
          // Mouse antigravity effect
          if (this.mouse.x !== null && this.mouse.y !== null) {
            const rect = this.canvas.getBoundingClientRect();
            const mouseX = this.mouse.x - rect.left;
            const mouseY = this.mouse.y - rect.top;
            
            const dx = mouseX - particle.x;
            const dy = mouseY - particle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < this.mouse.radius) {
              const force = (this.mouse.radius - distance) / this.mouse.radius;
              const angle = Math.atan2(dy, dx);
              // Push away from mouse (antigravity)
              particle.vx -= Math.cos(angle) * force * 0.3;
              particle.vy -= Math.sin(angle) * force * 0.3;
            }
          }
          
          // Damping
          particle.vx *= 0.98;
          particle.vy *= 0.98;
          
          // Boundary check with bounce
          if (particle.x < 0 || particle.x > this.canvas.width) {
            particle.vx *= -0.8;
            particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
          }
          if (particle.y < 0 || particle.y > this.canvas.height) {
            particle.vy *= -0.8;
            particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
          }
          
          // Draw particle with glow
          this.ctx.beginPath();
          this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
          this.ctx.fillStyle = `rgba(99, 102, 241, ${particle.opacity})`;
          this.ctx.shadowBlur = 8;
          this.ctx.shadowColor = `rgba(99, 102, 241, ${particle.opacity * 0.8})`;
          this.ctx.fill();
          this.ctx.shadowBlur = 0;
          
          // Draw connections (lighter)
          this.particles.slice(i + 1).forEach(otherParticle => {
            const dx = particle.x - otherParticle.x;
            const dy = particle.y - otherParticle.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 120) {
              this.ctx.beginPath();
              this.ctx.strokeStyle = `rgba(99, 102, 241, ${0.15 * (1 - distance / 120)})`;
              this.ctx.lineWidth = 0.5;
              this.ctx.moveTo(particle.x, particle.y);
              this.ctx.lineTo(otherParticle.x, otherParticle.y);
              this.ctx.stroke();
            }
          });
        });
      }
      
      animate() {
        this.drawParticles();
        this.animationId = requestAnimationFrame(() => this.animate());
      }
      
      setupEventListeners() {
        window.addEventListener('resize', () => {
          this.resize();
          this.createParticles();
        });
        
        const mouseMoveHandler = (e) => {
          this.mouse.x = e.clientX;
          this.mouse.y = e.clientY;
        };
        
        const mouseLeaveHandler = () => {
          this.mouse.x = null;
          this.mouse.y = null;
        };
        
        document.addEventListener('mousemove', mouseMoveHandler);
        document.addEventListener('mouseleave', mouseLeaveHandler);
        
        this.cleanupListeners = () => {
          document.removeEventListener('mousemove', mouseMoveHandler);
          document.removeEventListener('mouseleave', mouseLeaveHandler);
        };
      }
      
      destroy() {
        if (this.animationId) {
          cancelAnimationFrame(this.animationId);
        }
        if (this.cleanupListeners) {
          this.cleanupListeners();
        }
      }
    }
    
    // Initialize features particles
    function initFeaturesParticles() {
      const canvas = document.getElementById('features-particles-canvas');
      if (canvas && !canvas.particleSystem) {
        canvas.particleSystem = new FeaturesParticleSystem(canvas);
      }
    }
    
    // Initialize when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initFeaturesParticles);
    } else {
      initFeaturesParticles();
    }
  })();
  </script>
</div>

<!-- Features Section (optional) -->
{{ if .Params.features }}
  <div class="py-24 sm:py-32 bg-white dark:bg-gray-900" style="position: relative; overflow: hidden;">
    <!-- Floating Particles Canvas -->
    <canvas id="features-particles-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></canvas>
    
    <div class="wrapper" style="position: relative; z-index: 10;">
      <div class="mx-auto max-w-2xl lg:text-center mb-16">
        {{ if .Params.features_heading }}
          <h2 class="text-base font-semibold leading-7 text-indigo-600 dark:text-indigo-400">{{ .Params.features_heading }}</h2>
        {{ end }}
        {{ if .Params.features_title }}
          <p class="mt-2 text-3xl font-bold tracking-tight text-gray-900 dark:text-white sm:text-4xl">
            {{ .Params.features_title }}
          </p>
        {{ end }}
        {{ if .Params.features_description }}
          <p class="mt-6 text-lg leading-8 text-gray-600 dark:text-gray-400">
            {{ .Params.features_description }}
          </p>
        {{ end }}
      </div>
      
      <div class="mx-auto max-w-7xl">
        <dl class="grid max-w-xl grid-cols-1 gap-x-8 gap-y-10 lg:max-w-none lg:grid-cols-3 lg:gap-y-16">
          {{ range .Params.features }}
            <div class="relative pl-16">
              <dt class="text-base font-semibold leading-7 text-gray-900 dark:text-white">
                {{ if .icon }}
                  <div class="absolute left-0 top-0 flex h-10 w-10 items-center justify-center rounded-lg bg-indigo-600">
                    <svg class="h-6 w-6 text-white" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                      <path stroke-linecap="round" stroke-linejoin="round" d="{{ .icon }}" />
                    </svg>
                  </div>
                {{ end }}
                {{ .name }}
              </dt>
              <dd class="mt-2 text-base leading-7 text-gray-600 dark:text-gray-400">
                {{ .description }}
              </dd>
            </div>
          {{ end }}
        </dl>
      </div>
    </div>
  </div>
{{ end }}

<!-- Content from Markdown -->
{{ if .Content }}
  <div class="py-16 bg-gray-50 dark:bg-gray-800" style="position: relative; overflow: hidden;">
    <!-- Floating Particles Canvas -->
    <canvas id="content-particles-canvas" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 1;"></canvas>
    
    <div class="wrapper" style="position: relative; z-index: 10;">
      <div class="prose prose-lg dark:prose-invert mx-auto max-w-3xl">
        {{ .Content }}
      </div>
    </div>
  </div>
{{ end }}

<script>
(function() {
  'use strict';
  
  // Particle System (Antigravity Effect)
  class ParticleSystem {
    constructor(canvas) {
      this.canvas = canvas;
      this.ctx = canvas.getContext('2d');
      this.particles = [];
      this.particleCount = 80;
      this.mouse = { x: null, y: null, radius: 150 };
      
      this.init();
      this.animate();
      this.setupEventListeners();
    }
    
    init() {
      this.resize();
      this.createParticles();
    }
    
    resize() {
      this.canvas.width = window.innerWidth;
      this.canvas.height = window.innerHeight;
    }
    
    createParticles() {
      this.particles = [];
      for (let i = 0; i < this.particleCount; i++) {
        this.particles.push({
          x: Math.random() * this.canvas.width,
          y: Math.random() * this.canvas.height,
          radius: Math.random() * 3 + 1,
          vx: (Math.random() - 0.5) * 0.5,
          vy: (Math.random() - 0.5) * 0.5,
          opacity: Math.random() * 0.5 + 0.2
        });
      }
    }
    
    drawParticles() {
      this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
      
      this.particles.forEach((particle, i) => {
        // Update position
        particle.x += particle.vx;
        particle.y += particle.vy;
        
        // Mouse interaction (antigravity effect)
        if (this.mouse.x !== null && this.mouse.y !== null) {
          const dx = this.mouse.x - particle.x;
          const dy = this.mouse.y - particle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < this.mouse.radius) {
            const force = (this.mouse.radius - distance) / this.mouse.radius;
            const angle = Math.atan2(dy, dx);
            // Push away from mouse (antigravity)
            particle.vx -= Math.cos(angle) * force * 0.5;
            particle.vy -= Math.sin(angle) * force * 0.5;
          }
        }
        
        // Damping
        particle.vx *= 0.99;
        particle.vy *= 0.99;
        
        // Boundary check
        if (particle.x < 0 || particle.x > this.canvas.width) particle.vx *= -1;
        if (particle.y < 0 || particle.y > this.canvas.height) particle.vy *= -1;
        
        // Clamp position
        particle.x = Math.max(0, Math.min(this.canvas.width, particle.x));
        particle.y = Math.max(0, Math.min(this.canvas.height, particle.y));
        
        // Draw particle
        this.ctx.beginPath();
        this.ctx.arc(particle.x, particle.y, particle.radius, 0, Math.PI * 2);
        this.ctx.fillStyle = `rgba(255, 255, 255, ${particle.opacity})`;
        this.ctx.fill();
        
        // Draw connections - BRIGHTER AND THICKER
        this.particles.slice(i + 1).forEach(otherParticle => {
          const dx = particle.x - otherParticle.x;
          const dy = particle.y - otherParticle.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 150) {
            this.ctx.beginPath();
            this.ctx.strokeStyle = `rgba(255, 255, 255, ${0.4 * (1 - distance / 150)})`;
            this.ctx.lineWidth = 1.5;
            this.ctx.moveTo(particle.x, particle.y);
            this.ctx.lineTo(otherParticle.x, otherParticle.y);
            this.ctx.stroke();
          }
        });
      });
    }
    
    animate() {
      this.drawParticles();
      requestAnimationFrame(() => this.animate());
    }
    
    setupEventListeners() {
      window.addEventListener('resize', () => this.resize());
      
      window.addEventListener('mousemove', (e) => {
        this.mouse.x = e.clientX;
        this.mouse.y = e.clientY;
      });
      
      window.addEventListener('mouseleave', () => {
        this.mouse.x = null;
        this.mouse.y = null;
      });
    }
  }
  
  // Glow Orb Effect
  function setupGlowOrb() {
    const glowOrb = document.getElementById('heroGlowOrb');
    const heroGlow = document.getElementById('heroGlow');
    
    if (!glowOrb || !heroGlow) return;
    
    document.addEventListener('mousemove', function(e) {
      const glowRect = heroGlow.getBoundingClientRect();
      const relativeX = e.clientX - glowRect.left;
      const relativeY = e.clientY - glowRect.top;
      
      requestAnimationFrame(function() {
        glowOrb.style.left = relativeX + 'px';
        glowOrb.style.top = relativeY + 'px';
      });
    });
  }
  
  // Initialize
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('particles-canvas');
    if (canvas) {
      new ParticleSystem(canvas);
    }
    setupGlowOrb();
  });
})();
</script>
{{ end }}
